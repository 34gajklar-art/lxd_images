name: Build Simplestreams

on:
  schedule:
    - cron: '0 2 * * *'
  workflow_dispatch:

jobs:
  build-repository:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl

      - name: Fetch Release Assets
        run: |
          mkdir -p temp
          assets=$(curl -s "https://api.github.com/repos/oneclickvirt/lxd_images/releases" | jq -r '.[] | select(.tag_name=="processed") | .assets // empty')
          if [ "$assets" != "null" ] && [ "$assets" != "empty" ] && [ -n "$assets" ]; then
            echo "$assets" > temp/assets.json
          else
            echo "[]" > temp/assets.json
          fi

      - name: Process Image Information
        run: |
          cat > process_images.jq << 'EOF'
          [
            .[] |
            select(.name | test("^[a-z0-9]+-[0-9a-z\\.-]+-[a-z0-9]+-[a-z]+-rootfs\\.squashfs$")) |
            {
              name: .name,
              rootfs_url: .browser_download_url,
              rootfs_size: .size,
              lxd_name: (.name | sub("-rootfs\\.squashfs$"; "-lxd.tar.xz"))
            }
          ] |
          map(
            . as $rootfs |
            ($rootfs.name | capture("^(?<os>[a-z0-9]+)-(?<version>[0-9a-z\\.-]+)-(?<arch>[a-z0-9]+)-(?<variant>[a-z]+)-rootfs\\.squashfs$")) as $parsed |
            if $parsed then
              $rootfs + $parsed + {
                lxd_info: (
                  input_filename as $assets_file |
                  $assets_file |
                  map(select(.name == $rootfs.lxd_name)) |
                  if length > 0 then .[0] else null end
                )
              }
            else
              empty
            end
          ) |
          map(
            select(.lxd_info != null) |
            {
              os: .os,
              version: .version,
              arch: .arch,
              variant: .variant,
              rootfs_url: .rootfs_url,
              rootfs_size: .rootfs_size,
              lxd_url: .lxd_info.browser_download_url,
              lxd_size: .lxd_info.size,
              rootfs_sha256: "unknown",
              lxd_sha256: "unknown",
              combined_sha256: "unknown"
            }
          )
          EOF

          if [ "$(jq length temp/assets.json)" -gt 0 ]; then
            jq -f process_images.jq temp/assets.json > temp/processed_images.json
          else
            echo "[]" > temp/processed_images.json
          fi

      - name: Generate Simplestreams Metadata
        run: |
          mkdir -p pages/streams/v1
          if [ "$(jq length temp/processed_images.json)" -eq 0 ]; then
            cat > pages/streams/v1/images.json << 'EOF'
            {
              "datatype": "image-downloads",
              "format": "products:1.0",
              "products": {}
            }
            EOF

            cat > pages/streams/v1/index.json << 'EOF'
            {
              "index": {
                "images": {
                  "datatype": "image-downloads",
                  "path": "streams/v1/images.json",
                  "format": "products:1.0"
                }
              },
              "format": "index:1.0"
            }
            EOF
            exit 0
          fi

          current_time=$(date -u +"%Y%m%d_%H%M")
          echo "Using timestamp: $current_time"

          jq -n --slurpfile images temp/processed_images.json --arg updated "$current_time" '
          {
            "datatype": "image-downloads",
            "format": "products:1.0",
            "products": (
              $images[0] |
              group_by(.os) |
              map({
                key: .[0].os,
                value: {
                  "arch": (map(.arch) | unique | sort),
                  "release": .[0].os,
                  "os": .[0].os,
                  "versions": (
                    group_by(.version) |
                    map({
                      key: .[0].version,
                      value: {
                        "items": (
                          group_by(.arch) |
                          map({
                            key: .[0].arch,
                            value: (
                              group_by(.variant) |
                              map({
                                key: .[0].variant,
                                value: {
                                  "ftype": "squashfs",
                                  "os": .[0].os,
                                  "release": .[0].version,
                                  "version": .[0].version,
                                  "arch": .[0].arch,
                                  "variant": .[0].variant,
                                  "combined_sha256": .[0].combined_sha256,
                                  "path": ("images/" + .[0].os + "/" + .[0].version + "/" + .[0].arch + "/" + .[0].variant + "/"),
                                  "versions": {
                                    ($updated): {
                                      "items": {
                                        "lxd.tar.xz": {
                                          "ftype": "lxd.tar.xz",
                                          "size": .[0].lxd_size,
                                          "sha256": .[0].lxd_sha256,
                                          "path": ("redirect/lxd/" + (.lxd_url | @uri))
                                        },
                                        "rootfs.squashfs": {
                                          "ftype": "squashfs",
                                          "size": .[0].rootfs_size,
                                          "sha256": .[0].rootfs_sha256,
                                          "path": ("redirect/rootfs/" + (.rootfs_url | @uri))
                                        }
                                      }
                                    }
                                  }
                                }
                              }) |
                              from_entries
                            )
                          }) |
                          from_entries
                        )
                      }
                    }) |
                    from_entries
                  )
                }
              }) |
              from_entries
            )
          }' > pages/streams/v1/images.json

          cat > pages/streams/v1/index.json << 'EOF'
          {
            "index": {
              "images": {
                "datatype": "image-downloads",
                "path": "streams/v1/images.json",
                "format": "products:1.0"
              }
            },
            "format": "index:1.0"
          }
          EOF

      - name: Create Redirect Pages
        run: |
          mkdir -p pages/redirect/{lxd,rootfs}
          generate_redirect_page() {
            local url="$1"
            local filename="$2"
            cat > "$filename" << EOF
            <!DOCTYPE html>
            <html>
            <head>
              <meta http-equiv="refresh" content="0; url=$url">
              <meta name="robots" content="noindex">
              <title>Redirecting...</title>
            </head>
            <body>
              <p>Redirecting to <a href="$url">$url</a>...</p>
              <script>window.location.href = "$url";</script>
            </body>
            </html>
            EOF
          }

          if [ -f temp/processed_images.json ]; then
            jq -r '.[] | @base64' temp/processed_images.json | while IFS= read -r line; do
              if [ -n "$line" ]; then
                decoded=$(echo "$line" | base64 -d)
                lxd_url=$(echo "$decoded" | jq -r '.lxd_url')
                rootfs_url=$(echo "$decoded" | jq -r '.rootfs_url')
                lxd_encoded=$(echo "$lxd_url" | sed 's|:|%3A|g; s|/|%2F|g; s|?|%3F|g; s|&|%26|g')
                rootfs_encoded=$(echo "$rootfs_url" | sed 's|:|%3A|g; s|/|%2F|g; s|?|%3F|g; s|&|%26|g')
                generate_redirect_page "$lxd_url" "pages/redirect/lxd/$lxd_encoded"
                generate_redirect_page "$rootfs_url" "pages/redirect/rootfs/$rootfs_encoded"
              fi
            done
          fi

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./pages
          publish_branch: gh-pages
          force_orphan: true
          cname: false
