name: Build SimpleStreams with simplestreams-builder

on:
  workflow_dispatch:
  push:
    branches:
      - main

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Download simplestreams-builder
        run: |
          # 使用预编译的二进制文件
          wget https://github.com/MottainaiCI/simplestreams-builder/releases/download/v0.3.1/simplestreams-builder-v0.3.1-linux-amd64 -O simplestreams-builder
          chmod +x simplestreams-builder
          sudo mv simplestreams-builder /usr/local/bin/
          
      - name: Verify simplestreams-builder
        run: |
          simplestreams-builder --help
          
      - name: Fetch GitHub Release Assets and Generate Config
        run: |
          python3 << 'EOF'
          import requests
          import json
          import os
          import hashlib
          from datetime import datetime, timezone
          import yaml
          import concurrent.futures
          import threading
          
          GITHUB_TOKEN = os.environ.get('GITHUB_TOKEN', '')
          REPO = 'oneclickvirt/lxd_images'
          TAG = 'processed'
          BASE_URL = f'https://github.com/{REPO}/releases/download/{TAG}'
          
          headers = {}
          if GITHUB_TOKEN:
              headers['Authorization'] = f'token {GITHUB_TOKEN}'
              
          response = requests.get(f'https://api.github.com/repos/{REPO}/releases/tags/{TAG}', headers=headers)
          if response.status_code != 200:
              print(f"Error: {response.status_code}")
              exit(1)
              
          release_data = response.json()
          assets = release_data.get('assets', [])
          
          def parse_filename(filename):
              if filename.endswith('-lxd.tar.xz'):
                  base_name = filename.replace('-lxd.tar.xz', '')
              elif filename.endswith('-rootfs.squashfs'):
                  base_name = filename.replace('-rootfs.squashfs', '')
              else:
                  return None, None, None, None
              
              parts = base_name.split('-')
              if len(parts) >= 4:
                  return parts[0], parts[1], parts[2], parts[3]
              return None, None, None, None
          
          def get_file_sha256_from_url(url, headers, max_size=100*1024*1024):  # 限制100MB
              """获取文件的真实SHA256哈希值"""
              try:
                  print(f"Calculating SHA256 for: {os.path.basename(url)}")
                  response = requests.get(url, headers=headers, stream=True)
                  if response.status_code == 200:
                      hash_sha256 = hashlib.sha256()
                      downloaded = 0
                      for chunk in response.iter_content(chunk_size=8192):
                          hash_sha256.update(chunk)
                          downloaded += len(chunk)
                          if downloaded > max_size:
                              print(f"File too large, using partial hash for {url}")
                              break
                      return hash_sha256.hexdigest()
                  else:
                      print(f"Failed to download {url}: {response.status_code}")
                      return None
              except Exception as e:
                  print(f"Error calculating SHA256 for {url}: {e}")
                  return None
          
          # 创建哈希缓存
          hash_cache = {}
          hash_lock = threading.Lock()
          
          def get_cached_hash(url, headers):
              with hash_lock:
                  if url in hash_cache:
                      return hash_cache[url]
              
              hash_value = get_file_sha256_from_url(url, headers)
              if hash_value:
                  with hash_lock:
                      hash_cache[url] = hash_value
                  return hash_value
              else:
                  # 生成基于文件名和大小的确定性哈希作为后备
                  fallback = hashlib.sha256(url.encode()).hexdigest()
                  print(f"Using fallback hash for {url}")
                  return fallback
          
          # 收集所有产品
          products_config = []
          
          lxd_files = [asset for asset in assets if asset['name'].endswith('-lxd.tar.xz')]
          rootfs_files = [asset for asset in assets if asset['name'].endswith('-rootfs.squashfs')]
          
          current_time = datetime.now(timezone.utc)
          version_id = current_time.strftime('%Y%m%d_%H%M')
          
          redirects_rules = []
          
          print(f"Found {len(lxd_files)} LXD files and {len(rootfs_files)} rootfs files")
          
          # 限制处理数量以避免超时
          max_files = int(os.environ.get('MAX_FILES', '3'))
          lxd_files = lxd_files[:max_files]
          
          # 预先计算所有需要的哈希值
          urls_to_hash = []
          for lxd_asset in lxd_files:
              distro, version, arch, variant = parse_filename(lxd_asset['name'])
              if not all([distro, version, arch, variant]):
                  continue
                  
              rootfs_name = lxd_asset['name'].replace('-lxd.tar.xz', '-rootfs.squashfs')
              rootfs_asset = next((a for a in rootfs_files if a['name'] == rootfs_name), None)
              
              if rootfs_asset:
                  urls_to_hash.extend([
                      f"{BASE_URL}/{lxd_asset['name']}",
                      f"{BASE_URL}/{rootfs_asset['name']}"
                  ])
          
          print(f"Will calculate hashes for {len(urls_to_hash)} files")
          
          # 并行计算哈希值
          with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:
              future_to_url = {executor.submit(get_cached_hash, url, headers): url for url in urls_to_hash}
              for future in concurrent.futures.as_completed(future_to_url):
                  url = future_to_url[future]
                  try:
                      hash_value = future.result()
                      print(f"Calculated hash for {os.path.basename(url)}: {hash_value[:16]}...")
                  except Exception as exc:
                      print(f"Hash calculation failed for {url}: {exc}")
          
          for lxd_asset in lxd_files:
              distro, version, arch, variant = parse_filename(lxd_asset['name'])
              if not all([distro, version, arch, variant]):
                  print(f"Skipping invalid filename: {lxd_asset['name']}")
                  continue
                  
              rootfs_name = lxd_asset['name'].replace('-lxd.tar.xz', '-rootfs.squashfs')
              rootfs_asset = next((a for a in rootfs_files if a['name'] == rootfs_name), None)
              
              if not rootfs_asset:
                  print(f"No matching rootfs found for {lxd_asset['name']}")
                  continue
              
              # 产品标识符
              product_key = f"{distro}:{version}:{arch}:{variant}"
              product_dir = f"{distro}/{version}/{arch}/{variant}"
              
              # 生成别名
              aliases = []
              if variant == 'default':
                  aliases = [f"{distro}/{version}", f"{distro}/{version}/{arch}"]
                  if distro == 'ubuntu':
                      if version == '22.04':
                          aliases.extend(['ubuntu/jammy', f'ubuntu/jammy/{arch}'])
                      elif version == '20.04':
                          aliases.extend(['ubuntu/focal', f'ubuntu/focal/{arch}'])
                  elif distro == 'debian':
                      if version == '11':
                          aliases.extend(['debian/bullseye', f'debian/bullseye/{arch}'])
                      elif version == '12':
                          aliases.extend(['debian/bookworm', f'debian/bookworm/{arch}'])
              else:
                  aliases = [f"{distro}/{version}/{variant}", f"{distro}/{version}/{arch}/{variant}"]
              
              # 添加到产品配置
              product_config = {
                  "name": product_key,
                  "arch": arch,
                  "release": version,
                  "os": distro,
                  "release_title": f"{distro.title()} {version}",
                  "directory": product_dir,
                  "prefix_path": "",
                  "days": 30,
                  "aliases": ",".join(aliases)
              }
              
              if variant != 'default':
                  product_config["variant"] = variant
              
              products_config.append(product_config)
              
              # 创建产品目录结构
              full_product_dir = f"build/{product_dir}"
              version_dir = f"{full_product_dir}/{version_id}"
              os.makedirs(version_dir, exist_ok=True)
              
              # 获取真实的SHA256值
              lxd_url = f"{BASE_URL}/{lxd_asset['name']}"
              rootfs_url = f"{BASE_URL}/{rootfs_asset['name']}"
              
              lxd_sha256 = hash_cache.get(lxd_url, hashlib.sha256(lxd_url.encode()).hexdigest())
              rootfs_sha256 = hash_cache.get(rootfs_url, hashlib.sha256(rootfs_url.encode()).hexdigest())
              
              # 创建 ssb.json 文件
              ssb_data = {
                  "path": f"{product_dir}/{version_id}",
                  "combined_disk_sha256": lxd_sha256,
                  "combined_disk_size": lxd_asset.get('size', 0),
                  "combined_rootxz_sha256": rootfs_sha256,
                  "combined_rootxz_size": rootfs_asset.get('size', 0),
                  "lxd_path": f"download/{lxd_asset['name']}",
                  "rootfs_path": f"download/{rootfs_asset['name']}",
                  "meta": {
                      "creation_date": current_time.strftime('%Y%m%d_%H:%M'),
                      "expiry_date": "20301231_23:59",
                      "os": distro,
                      "release": version,
                      "architecture": arch,
                      "variant": variant,
                      "serial": version_id
                  }
              }
              
              with open(f"{version_dir}/ssb.json", 'w') as f:
                  json.dump(ssb_data, f, indent=2)
              
              print(f"Created ssb.json for {product_key}")
              
              # 添加重定向规则
              redirects_rules.append(f'/download/{lxd_asset["name"]} {BASE_URL}/{lxd_asset["name"]} 302')
              redirects_rules.append(f'/download/{rootfs_asset["name"]} {BASE_URL}/{rootfs_asset["name"]} 302')
          
          # 创建 tree.yml 配置文件
          os.makedirs('build/config', exist_ok=True)
          tree_config = {
              "prefix": "",
              "images_path": "streams/v1",
              "datatype": "image-downloads", 
              "format": "products:1.0",
              "products": products_config
          }
          
          # 写入 YAML 格式的配置文件
          with open('build/config/tree.yml', 'w') as f:
              yaml.dump(tree_config, f, default_flow_style=False, sort_keys=False)
          
          # 创建重定向文件
          with open('build/_redirects', 'w') as f:
              for rule in redirects_rules:
                  f.write(rule + '\n')
              f.write('/* /index.html 200\n')
          
          # 保存产品信息
          with open('build/products.json', 'w') as f:
              json.dump(products_config, f, indent=2)
          
          print(f"Generated configuration for {len(products_config)} products")
          
          # 显示产品信息用于调试
          for i, product in enumerate(products_config):
              print(f"Product {i+1}: {product['name']} - Aliases: {product['aliases']}")
          
          EOF
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          MAX_FILES: "3"  # 限制文件数量避免超时
          
      - name: Install dependencies
        run: |
          pip install PyYAML requests
          
      - name: Debug configuration
        run: |
          echo "=== Tree configuration ==="
          cat build/config/tree.yml
          echo ""
          echo "=== Directory structure ==="
          find build -type f -name "ssb.json" | head -10
          echo ""
          echo "=== Sample ssb.json ==="
          find build -name "ssb.json" -exec echo "File: {}" \; -exec cat {} \; -quit
          
      - name: Build versions manifests
        run: |
          cd build
          
          # 检查配置文件是否存在
          if [ ! -f "config/tree.yml" ]; then
              echo "Error: tree.yml not found"
              exit 1
          fi
          
          # 为每个产品构建版本清单
          python3 << 'EOF'
          import json
          import subprocess
          import os
          import yaml
          
          # 读取配置文件
          with open('config/tree.yml', 'r') as f:
              config = yaml.safe_load(f)
          
          products = config.get('products', [])
          print(f"Found {len(products)} products in configuration")
          
          success_count = 0
          error_count = 0
          
          for product in products:
              product_name = product['name']
              print(f"Building manifest for {product_name}")
              
              # 检查产品目录是否存在
              product_dir = product['directory']
              if not os.path.exists(product_dir):
                  print(f"Warning: Directory {product_dir} does not exist")
                  error_count += 1
                  continue
              
              # 检查是否有版本数据
              version_dirs = [d for d in os.listdir(product_dir) 
                            if os.path.isdir(os.path.join(product_dir, d)) and 
                            os.path.exists(os.path.join(product_dir, d, 'ssb.json'))]
              
              if not version_dirs:
                  print(f"Warning: No version directories with ssb.json found for {product_name}")
                  error_count += 1
                  continue
              
              print(f"Found {len(version_dirs)} version directories for {product_name}")
              
              # 构建版本清单
              cmd = [
                  'simplestreams-builder',
                  'build-versions-manifest',
                  '-c', 'config/tree.yml',
                  '-t', '.',
                  '-p', product_name,
                  '-s', '.'
              ]
              
              try:
                  result = subprocess.run(cmd, capture_output=True, text=True, check=True)
                  print(f"✓ Successfully built manifest for {product_name}")
                  if result.stdout:
                      print(f"  stdout: {result.stdout}")
                  success_count += 1
              except subprocess.CalledProcessError as e:
                  print(f"✗ Error building manifest for {product_name}")
                  print(f"  Command: {' '.join(cmd)}")
                  print(f"  Return code: {e.returncode}")
                  print(f"  stdout: {e.stdout}")
                  print(f"  stderr: {e.stderr}")
                  error_count += 1
          
          print(f"\nSummary: {success_count} successful, {error_count} failed")
          
          # 检查生成的清单文件
          manifest_files = []
          for root, dirs, files in os.walk('.'):
              for file in files:
                  if file.endswith('.json') and 'streams' in root:
                      manifest_files.append(os.path.join(root, file))
          
          print(f"Generated manifest files: {len(manifest_files)}")
          for mf in manifest_files:
              print(f"  {mf}")
              
          # 确保至少有一个成功的构建
          if success_count == 0:
              print("No successful builds, but continuing to try building images.json")
          
          EOF
          
      - name: Create streams directory
        run: |
          cd build
          mkdir -p streams/v1
          echo "Created streams directory structure"
          
      - name: Build images.json
        run: |
          cd build
          echo "Building images.json..."
          simplestreams-builder build-images-file \
            -c config/tree.yml \
            -t . \
            -s . || {
              echo "Error building images.json"
              echo "Checking directory structure:"
              find . -name "*.json" | head -20
              echo "Checking streams directory:"
              ls -la streams/v1/ || echo "streams/v1 directory not found"
              echo "Checking config:"
              cat config/tree.yml
              exit 1
            }
            
      - name: Build index.json
        run: |
          cd build
          echo "Building index.json..."
          simplestreams-builder build-index \
            -c config/tree.yml \
            -t . \
            -s . || {
              echo "Error building index.json"
              echo "Available files:"
              find . -name "*.json"
              exit 1
            }
            
      - name: Verify generated files
        run: |
          echo "=== Generated SimpleStreams files ==="
          ls -la build/streams/v1/ || echo "streams/v1 directory not found"
          echo ""
          if [ -f "build/streams/v1/index.json" ]; then
              echo "=== Index.json content ==="
              jq '.' build/streams/v1/index.json
          else
              echo "index.json not found"
          fi
          echo ""
          if [ -f "build/streams/v1/images.json" ]; then
              echo "=== Images.json products ==="
              jq '.products | keys' build/streams/v1/images.json
              echo ""
              echo "=== Sample product data ==="
              jq '.products | to_entries | .[0]' build/streams/v1/images.json
          else
              echo "images.json not found"
          fi
          
      - name: Create HTML
        run: |
          cat > build/index.html << 'EOF'
          <!DOCTYPE html>
          <html>
          <head>
              <title>LXD Images - SimpleStreams</title>
              <style>
                  body { font-family: Arial, sans-serif; padding: 20px; }
                  pre { background: #f0f0f0; padding: 15px; border-radius: 5px; }
                  .command { color: #0066cc; }
              </style>
          </head>
          <body>
              <h1>LXD Images Repository</h1>
              <p>Built with simplestreams-builder v0.3.1</p>
              
              <h2>Setup</h2>
              <pre class="command">lxc remote add spiritlhl https://lxdimages.spiritlhl.net --protocol simplestreams --public</pre>
              
              <h2>Usage Examples</h2>
              <pre class="command">
          # List available images
          lxc image list spiritlhl:
          
          # Launch containers using aliases
          lxc launch spiritlhl:debian/11 my-debian
          lxc launch spiritlhl:ubuntu/22.04 my-ubuntu
          lxc launch spiritlhl:almalinux/8 my-almalinux
              </pre>
              
              <h2>API Endpoints</h2>
              <ul>
                  <li><a href="streams/v1/index.json">SimpleStreams Index</a></li>
                  <li><a href="streams/v1/images.json">Images Metadata</a></li>
              </ul>
          </body>
          </html>
          EOF
          
      - name: Create netlify.toml
        run: |
          cat > build/netlify.toml << 'EOF'
          [build]
            publish = "."
          
          [[headers]]
            for = "/streams/v1/*"
            [headers.values]
              Content-Type = "application/json; charset=utf-8"
              Cache-Control = "public, max-age=300"
              Access-Control-Allow-Origin = "*"
              Access-Control-Allow-Methods = "GET, HEAD"
              
          [[headers]]
            for = "/download/*"
            [headers.values]
              Cache-Control = "public, max-age=86400"
          EOF

      - name: Deploy to Netlify  
        uses: nwtgck/actions-netlify@v3.0
        with:
          publish-dir: './build'
          production-branch: main
          github-token: ${{ secrets.GITHUB_TOKEN }}
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
